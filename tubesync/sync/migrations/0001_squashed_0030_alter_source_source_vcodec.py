# Manually adjusted based on the generated file.
# Generated by Django 5.1.8 on 2025-04-10 15:29

import django.core.files.storage
import django.core.validators
import django.db.models.deletion
import sync.fields
import sync.models
import uuid
from django.db import migrations, models


# Functions from the following migrations need manual copying.
# Move them and any dependencies into this file, then update the
# RunPython operations to refer to the local versions:
# sync.migrations.0013_fix_elative_media_file
from django.conf import settings
from pathlib import Path

def fix_media_file(apps, schema_editor):
    Media = apps.get_model('sync', 'Media')
    download_dir = str(settings.DOWNLOAD_ROOT)
    download_dir_path = Path(download_dir)
    for media in Media.objects.filter(downloaded=True):
        if media.media_file.path.startswith(download_dir):
            media_path = Path(media.media_file.path)
            relative_path = media_path.relative_to(download_dir_path)
            media.media_file.name = str(relative_path)
            media.save()

# Function above has been copied/modified and RunPython operations adjusted.

def media_file_location():
    return str(settings.DOWNLOAD_ROOT)

# Used the above function for storage location.

class Migration(migrations.Migration):

    replaces = [
        ('sync', '0001_initial_squashed_0010_auto_20210924_0554'),
        ('sync', '0011_auto_20220201_1654_squashed_0020_auto_20231024_1825'),
        ('sync', '0021_source_copy_channel_images'),
        ('sync', '0022_add_delete_files_on_disk'),
        ('sync', '0023_media_duration_filter'),
        ('sync', '0024_auto_20240717_1535'),
        ('sync', '0025_add_video_type_support'),
        ('sync', '0026_alter_source_sub_langs'),
        ('sync', '0027_alter_source_sponsorblock_categories'),
        ('sync', '0028_alter_source_source_resolution'),
        ('sync', '0029_alter_mediaserver_fields'),
        ('sync', '0030_alter_source_source_vcodec'),
    ]

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Source',
            fields=[
                ('uuid', models.UUIDField(
                    default=uuid.uuid4, editable=False, help_text='UUID of the source', primary_key=True, serialize=False, verbose_name='uuid',
                )),
                ('created', models.DateTimeField(
                    auto_now_add=True, db_index=True, help_text='Date and time the source was created', verbose_name='created',
                )),
                ('last_crawl', models.DateTimeField(
                    blank=True, db_index=True, help_text='Date and time the source was last crawled', null=True, verbose_name='last crawl',
                )),
                ('source_type', models.CharField(
                    choices=[('c', 'YouTube channel'), ('i', 'YouTube channel by ID'), ('p', 'YouTube playlist')], db_index=True, default='c', help_text='Source type', max_length=1, verbose_name='source type',
                )),
                ('key', models.CharField(
                    db_index=True, help_text='Source key, such as exact YouTube channel name or playlist ID', max_length=100, unique=True, verbose_name='key',
                )),
                ('name', models.CharField(
                    db_index=True, help_text='Friendly name for the source, used locally in TubeSync only', max_length=100, unique=True, verbose_name='name',
                )),
                ('directory', models.CharField(
                    db_index=True, help_text='Directory name to save the media into', max_length=100, unique=True, verbose_name='directory',
                )),
                ('index_schedule', models.IntegerField(
                    choices=[(3600, 'Every hour'), (7200, 'Every 2 hours'), (10800, 'Every 3 hours'), (14400, 'Every 4 hours'), (18000, 'Every 5 hours'), (21600, 'Every 6 hours'), (43200, 'Every 12 hours'), (86400, 'Every 24 hours'), (259200, 'Every 3 days'), (604800, 'Every 7 days'), (0, 'Never')], db_index=True, default=86400, help_text='Schedule of how often to index the source for new media', verbose_name='index schedule',
                )),
                ('delete_old_media', models.BooleanField(
                    default=False, help_text='Delete old media after "days to keep" days?', verbose_name='delete old media',
                )),
                ('days_to_keep', models.PositiveSmallIntegerField(
                    default=14, help_text='If "delete old media" is ticked, the number of days after which to automatically delete media', verbose_name='days to keep',
                )),
                ('source_resolution', models.CharField(
                    choices=[('360p', '360p (SD)'), ('480p', '480p (SD)'), ('720p', '720p (HD)'), ('1080p', '1080p (Full HD)'), ('1440p', '1440p (2K)'), ('2160p', '2160p (4K)'), ('4320p', '4320p (8K)'), ('audio', 'Audio only')], db_index=True, default='1080p', help_text='Source resolution, desired video resolution to download', max_length=8, verbose_name='source resolution',
                )),
                ('source_vcodec', models.CharField(
                    choices=[('AVC1', 'AVC1 (H.264)'), ('VP9', 'VP9')], db_index=True, default='VP9', help_text='Source video codec, desired video encoding format to download (ignored if "resolution" is audio only)', max_length=8, verbose_name='source video codec',
                )),
                ('source_acodec', models.CharField(
                    choices=[('MP4A', 'MP4A'), ('OPUS', 'OPUS')], db_index=True, default='OPUS', help_text='Source audio codec, desired audio encoding format to download', max_length=8, verbose_name='source audio codec',
                )),
                ('prefer_60fps', models.BooleanField(
                    default=True, help_text='Where possible, prefer 60fps media for this source', verbose_name='prefer 60fps',
                )),
                ('prefer_hdr', models.BooleanField(
                    default=False, help_text='Where possible, prefer HDR media for this source', verbose_name='prefer hdr',
                )),
                ('fallback', models.CharField(
                    choices=[('f', 'Fail, do not download any media'), ('n', 'Get next best resolution or codec instead'), ('h', 'Get next best resolution but at least HD')], db_index=True, default='h', help_text='What do do when media in your source resolution and codecs is not available', max_length=1, verbose_name='fallback',
                )),
                ('has_failed', models.BooleanField(
                    default=False, help_text='Source has failed to index media', verbose_name='has failed',
                )),
                ('copy_thumbnails', models.BooleanField(
                    default=False, help_text='Copy thumbnails with the media, these may be detected and used by some media servers', verbose_name='copy thumbnails',
                )),
                ('media_format', models.CharField(
                    default='{yyyy_mm_dd}_{source}_{title}_{key}_{format}.{ext}', help_text='File format to use for saving files, detailed options at bottom of page.', max_length=200, verbose_name='media format',
                )),
                ('write_nfo', models.BooleanField(
                    default=False, help_text='Write an NFO file in XML with the media info, these may be detected and used by some media servers', verbose_name='write nfo',
                )),
                ('download_cap', models.IntegerField(
                    choices=[(0, 'No cap'), (604800, '1 week (7 days)'), (2592000, '1 month (30 days)'), (7776000, '3 months (90 days)'), (15552000, '6 months (180 days)'), (31536000, '1 year (365 days)'), (63072000, '2 years (730 days)'), (94608000, '3 years (1095 days)'), (157680000, '5 years (1825 days)'), (315360000, '10 years (3650 days)')], default=0, help_text='Do not download media older than this capped date', verbose_name='download cap',
                )),
                ('download_media', models.BooleanField(
                    default=True, help_text='Download media from this source, if not selected the source will only be indexed', verbose_name='download media',
                )),
                ('write_json', models.BooleanField(
                    default=False, help_text='Write a JSON file with the media info, these may be detected and used by some media servers', verbose_name='write json',
                )),
            ],
            options={
                'verbose_name': 'Source',
                'verbose_name_plural': 'Sources',
            },
        ),
        migrations.CreateModel(
            name='MediaServer',
            fields=[
                ('id', models.AutoField(
                    auto_created=True, primary_key=True, serialize=False, verbose_name='ID',
                )),
                ('server_type', models.CharField(
                    choices=[('p', 'Plex')], db_index=True, default='p', help_text='Server type', max_length=1, verbose_name='server type',
                )),
                ('host', models.CharField(
                    db_index=True, help_text='Hostname or IP address of the media server', max_length=200, verbose_name='host',
                )),
                ('port', models.PositiveIntegerField(
                    db_index=True, help_text='Port number of the media server', verbose_name='port',
                )),
                ('use_https', models.BooleanField(
                    default=True, help_text='Connect to the media server over HTTPS', verbose_name='use https',
                )),
                ('verify_https', models.BooleanField(
                    default=False, help_text='If connecting over HTTPS, verify the SSL certificate is valid', verbose_name='verify https',
                )),
                ('options', models.TextField(
                    blank=True, help_text='JSON encoded options for the media server', null=True, verbose_name='options',
                )),
            ],
            options={
                'verbose_name': 'Media Server',
                'verbose_name_plural': 'Media Servers',
                'unique_together': {('host', 'port')},
            },
        ),
        migrations.CreateModel(
            name='Media',
            fields=[
                ('uuid', models.UUIDField(
                    default=uuid.uuid4, editable=False, help_text='UUID of the media', primary_key=True, serialize=False, verbose_name='uuid',
                )),
                ('created', models.DateTimeField(
                    auto_now_add=True, db_index=True, help_text='Date and time the media was created', verbose_name='created',
                )),
                ('published', models.DateTimeField(
                    blank=True, db_index=True, help_text='Date and time the media was published on the source', null=True, verbose_name='published',
                )),
                ('key', models.CharField(
                    db_index=True, help_text='Media key, such as exact YouTube video ID', max_length=100, verbose_name='key',
                )),
                ('thumb', models.ImageField(
                    blank=True, height_field='thumb_height', help_text='Thumbnail', max_length=200, null=True, upload_to=sync.models.get_media_thumb_path, verbose_name='thumb', width_field='thumb_width',
                )),
                ('thumb_width', models.PositiveSmallIntegerField(
                    blank=True, help_text='Width (X) of the thumbnail', null=True, verbose_name='thumb width',
                )),
                ('thumb_height', models.PositiveSmallIntegerField(
                    blank=True, help_text='Height (Y) of the thumbnail', null=True, verbose_name='thumb height',
                )),
                ('metadata', models.TextField(
                    blank=True, help_text='JSON encoded metadata for the media', null=True, verbose_name='metadata',
                )),
                ('can_download', models.BooleanField(
                    db_index=True, default=False, help_text='Media has a matching format and can be downloaded', verbose_name='can download',
                )),
                ('media_file', models.FileField(
                    blank=True, help_text='Media file', max_length=255, null=True, storage=django.core.files.storage.FileSystemStorage(location=media_file_location()), upload_to=sync.models.get_media_file_path, verbose_name='media file',
                )),
                ('skip', models.BooleanField(
                    db_index=True, default=False, help_text='Media will be skipped and not downloaded', verbose_name='skip',
                )),
                ('downloaded', models.BooleanField(
                    db_index=True, default=False, help_text='Media has been downloaded', verbose_name='downloaded',
                )),
                ('download_date', models.DateTimeField(
                    blank=True, db_index=True, help_text='Date and time the download completed', null=True, verbose_name='download date',
                )),
                ('downloaded_format', models.CharField(
                    blank=True, help_text='Video format (resolution) of the downloaded media', max_length=30, null=True, verbose_name='downloaded format',
                )),
                ('downloaded_height', models.PositiveIntegerField(
                    blank=True, help_text='Height in pixels of the downloaded media', null=True, verbose_name='downloaded height',
                )),
                ('downloaded_width', models.PositiveIntegerField(
                    blank=True, help_text='Width in pixels of the downloaded media', null=True, verbose_name='downloaded width',
                )),
                ('downloaded_audio_codec', models.CharField(
                    blank=True, help_text='Audio codec of the downloaded media', max_length=30, null=True, verbose_name='downloaded audio codec',
                )),
                ('downloaded_video_codec', models.CharField(
                    blank=True, help_text='Video codec of the downloaded media', max_length=30, null=True, verbose_name='downloaded video codec',
                )),
                ('downloaded_container', models.CharField(
                    blank=True, help_text='Container format of the downloaded media', max_length=30, null=True, verbose_name='downloaded container format',
                )),
                ('downloaded_fps', models.PositiveSmallIntegerField(
                    blank=True, help_text='FPS of the downloaded media', null=True, verbose_name='downloaded fps',
                )),
                ('downloaded_hdr', models.BooleanField(
                    default=False, help_text='Downloaded media has HDR', verbose_name='downloaded hdr',
                )),
                ('downloaded_filesize', models.PositiveBigIntegerField(
                    blank=True, db_index=True, help_text='Size of the downloaded media in bytes', null=True, verbose_name='downloaded filesize',
                )),
                ('source', models.ForeignKey(
                    help_text='Source the media belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='media_source', to='sync.source',
                )),
            ],
            options={
                'verbose_name': 'Media',
                'verbose_name_plural': 'Media',
                'unique_together': {('source', 'key')},
            },
        ),
        migrations.AlterField(
            model_name='media',
            name='media_file',
            field=models.FileField(blank=True, help_text='Media file', max_length=255, null=True, storage=django.core.files.storage.FileSystemStorage(base_url='/media-data/', location=media_file_location()), upload_to=sync.models.get_media_file_path, verbose_name='media file'),
        ),
        migrations.AlterField(
            model_name='media',
            name='skip',
            field=models.BooleanField(db_index=True, default=False, help_text='INTERNAL FLAG - Media will be skipped and not downloaded', verbose_name='skip'),
        ),
        migrations.AddField(
            model_name='source',
            name='embed_metadata',
            field=models.BooleanField(default=False, help_text='Embed metadata from source into file', verbose_name='embed metadata'),
        ),
        migrations.AddField(
            model_name='source',
            name='embed_thumbnail',
            field=models.BooleanField(default=False, help_text='Embed thumbnail into the file', verbose_name='embed thumbnail'),
        ),
        migrations.AddField(
            model_name='source',
            name='enable_sponsorblock',
            field=models.BooleanField(default=True, help_text='Use SponsorBlock?', verbose_name='enable sponsorblock'),
        ),
        migrations.AddField(
            model_name='source',
            name='write_subtitles',
            field=models.BooleanField(default=False, help_text='Download video subtitles', verbose_name='write subtitles'),
        ),
        migrations.AddField(
            model_name='source',
            name='delete_removed_media',
            field=models.BooleanField(default=False, help_text='Delete media that is no longer on this playlist', verbose_name='delete removed media'),
        ),
        migrations.AddField(
            model_name='source',
            name='auto_subtitles',
            field=models.BooleanField(default=False, help_text='Accept auto-generated subtitles', verbose_name='accept auto-generated subs'),
        ),
        migrations.AddField(
            model_name='source',
            name='copy_channel_images',
            field=models.BooleanField(default=False, help_text='Copy channel banner and avatar. These may be detected and used by some media servers', verbose_name='copy channel images'),
        ),
        migrations.AddField(
            model_name='source',
            name='delete_files_on_disk',
            field=models.BooleanField(default=False, help_text='Delete files on disk when they are removed from TubeSync', verbose_name='delete files on disk'),
        ),
        migrations.AddField(
            model_name='media',
            name='duration',
            field=models.PositiveIntegerField(blank=True, help_text='Duration of media in seconds', null=True, verbose_name='duration'),
        ),
        migrations.AddField(
            model_name='source',
            name='filter_seconds',
            field=models.PositiveIntegerField(blank=True, help_text='Filter Media based on Min/Max duration. Leave blank or 0 to disable filtering', null=True, verbose_name='filter seconds'),
        ),
        migrations.AddField(
            model_name='source',
            name='filter_seconds_min',
            field=models.BooleanField(choices=[(True, 'Minimum Length'), (False, 'Maximum Length')], default=True, help_text='When Filter Seconds is > 0, do we skip on minimum (video shorter than limit) or maximum (video greater than maximum) video duration', verbose_name='filter seconds min/max'),
        ),
        migrations.AddField(
            model_name='source',
            name='filter_text_invert',
            field=models.BooleanField(default=False, help_text='Invert filter string regex match, skip any matching titles when selected', verbose_name='invert filter text matching'),
        ),
        migrations.AddField(
            model_name='media',
            name='manual_skip',
            field=models.BooleanField(db_index=True, default=False, help_text='Media marked as "skipped", won\'t be downloaded', verbose_name='manual_skip'),
        ),
        migrations.AddField(
            model_name='media',
            name='title',
            field=models.CharField(blank=True, default='', help_text='Video title', max_length=200, verbose_name='title'),
        ),
        migrations.AddField(
            model_name='source',
            name='filter_text',
            field=models.CharField(blank=True, default='', help_text='Regex compatible filter string for video titles', max_length=200, verbose_name='filter string'),
        ),
        migrations.AddField(
            model_name='source',
            name='index_videos',
            field=models.BooleanField(default=True, help_text='Index video media from this source', verbose_name='index videos'),
        ),
        migrations.AddField(
            model_name='source',
            name='index_streams',
            field=models.BooleanField(default=False, help_text='Index live stream media from this source', verbose_name='index streams'),
        ),
        migrations.AddField(
            model_name='source',
            name='sub_langs',
            field=models.CharField(default='en', help_text='List of subtitles langs to download, comma-separated. Example: en,fr or all,-fr,-live_chat', max_length=30, validators=[django.core.validators.RegexValidator(message='Subtitle langs must be a comma-separated list of langs. example: en,fr or all,-fr,-live_chat', regex='^(\\-?[\\_\\.a-zA-Z-]+(,|$))+')], verbose_name='subs langs'),
        ),
        migrations.AddField(
            model_name='source',
            name='sponsorblock_categories',
            field=sync.fields.CommaSepChoiceField(all_choice='all', all_label='(All Categories)', allow_all=True, default='all', help_text='Select the SponsorBlock categories that you wish to be removed from downloaded videos.', max_length=128, possible_choices=[('sponsor', 'Sponsor'), ('intro', 'Intermission/Intro Animation'), ('outro', 'Endcards/Credits'), ('selfpromo', 'Unpaid/Self Promotion'), ('preview', 'Preview/Recap'), ('filler', 'Filler Tangent'), ('interaction', 'Interaction Reminder'), ('music_offtopic', 'Non-Music Section')], verbose_name=''),
        ),
        migrations.AlterField(
            model_name='source',
            name='source_resolution',
            field=models.CharField(choices=[('audio', 'Audio only'), ('360p', '360p (SD)'), ('480p', '480p (SD)'), ('720p', '720p (HD)'), ('1080p', '1080p (Full HD)'), ('1440p', '1440p (2K)'), ('2160p', '2160p (4K)'), ('4320p', '4320p (8K)')], db_index=True, default='1080p', help_text='Source resolution, desired video resolution to download', max_length=8, verbose_name='source resolution'),
        ),
        migrations.AlterField(
            model_name='mediaserver',
            name='options',
            field=models.TextField(help_text='JSON encoded options for the media server', null=True, verbose_name='options'),
        ),
        migrations.AlterField(
            model_name='mediaserver',
            name='server_type',
            field=models.CharField(choices=[('j', 'Jellyfin'), ('p', 'Plex')], db_index=True, default='p', help_text='Server type', max_length=1, verbose_name='server type'),
        ),
        migrations.AlterField(
            model_name='mediaserver',
            name='use_https',
            field=models.BooleanField(default=False, help_text='Connect to the media server over HTTPS', verbose_name='use https'),
        ),
        migrations.AlterField(
            model_name='mediaserver',
            name='verify_https',
            field=models.BooleanField(default=True, help_text='If connecting over HTTPS, verify the SSL certificate is valid', verbose_name='verify https'),
        ),
        migrations.AlterField(
            model_name='source',
            name='source_vcodec',
            field=models.CharField(choices=[('AVC1', 'AVC1 (H.264)'), ('VP9', 'VP9'), ('AV1', 'AV1')], db_index=True, default='VP9', help_text='Source video codec, desired video encoding format to download (ignored if "resolution" is audio only)', max_length=8, verbose_name='source video codec'),
        ),
        migrations.RunPython(
            code=fix_media_file,
            reverse_code=migrations.RunPython.noop,
        ),
    ]
